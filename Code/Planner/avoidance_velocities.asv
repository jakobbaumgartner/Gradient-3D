function q_avoid = avoidance_velocities(robot_angles, space_resolution, grid_distance)

    % avoidance_velocities - calculates the avoidance velocities for a robot
    %
    % Inputs:
    %   robot_angles - vector of robot joint angles 
    %                  [x_base y_base phi_base f1 ... fi7]
    %
    %   space_resolution - resolution of the obstacle distance-density space grid
    %   grid_distance - 3D matrix representing the distance-density grid
    %
    % Outputs:
    %   q_avoid - avoidance velocities for the robot


    % set numerical step size
    dd=0.005; % cca 5mm
    df=0.01; % ccca 0.5 stopinje
    delta=[dd df df df df df df df df]; % [v w dq1 ... dq7]
    dq_zeros=zeros(1,9);


    % calculate EE position
    [T] = GeometricRobot(robot_angles);

    % get EE position
    point = T(1:3,4) * space_resolution;
     
    % get nearby grid cells positions
    X = [floor(point(1)) floor(point(1))+1];
    Y = [floor(point(2)) floor(point(2))+1];
    Z = [floor(point(3)) floor(point(3))+1];
     
    % get values of nearby cells
    V = ones(2,2,2);
    for x = 1:1:2 
        for y = 1:1:2
            for z = 1:1:2
                V(y,x,z) = grid_distance(y,x,z);
            end
        end
    end

%     Example:
    %     % Perform trilinear interpolation using interp3
    %     Vq = interp3(X,Y,Z,V,point(1),point(2),point(3))

    % BASE ONLY
   
    
    % for every joint
    for i = 1:1:2

            % pick specific joint positive or negative velocities
            q_vel1 = dq_zeros;
            q_vel1(i)=delta(i);

            q_vel2 = dq_zeros;
            q_vel2(i) = - delta(i);

            % simulate robot changes with these velocities
            rob_state1 = simulate_step(robot_angles, q_vel1);
            qq1 = simulate_step(robot_angles, q_vel2);

            % calculate positions of base point after changes
            [~, Abase1] = GeometricRobot(qq1);
            [~, Abase1] = GeometricRobot(qq1);


        
        

        


    end



end