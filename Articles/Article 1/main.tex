% !TeX spellcheck = en_US
\documentclass[]{article}

\usepackage{amsmath, xparse}

 \usepackage{easyReview}


%opening
\title{\comment{3D Voxel Grid Based Path Planning for Robotic Manipulators using Matrix Multiplication Technique}{Alternatives:\\ - Efficient distance calculation / Efficient repulsive field calculation technique \\   - Matrix Multiplication-Driven Repulsive Fields for 3D Voxel-Based Robotic Manipulator Path Planning \\ - Robotic Manipulator Path Planning Optimization Using Matrix-Derived Repulsive Fields Based on 3D Voxel Grid}}

\author{Jakob Baumgartner, Gregor Klanƒçar}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

\section{Background}

\todo{1-2 PAGES}

\add{
	- PRESENT DISTANCE CALCULATION FOR MANIPULATORS (sensors, lidar, ir, bounding boxes) \\
	- PRESENT PATH PLANNING METHODS FOR MANIPULATOR (optimization, sampling, biological, learning) \\
	- similar to Distance Transform (a kind of inverted distance transform) \\
	- method was inspired by Khatib APF (however, it evolved into a different method) \\
	- different existing APF manipulator implementation articles \\
	- VFH \\
}

\section{Methodology}

\todo{3 PAGES}

\subsection{Optimization Algorithm}

\add{
	- optimization algorithm \\
	- robot kinematics (include the exact-reduced method) \\
	- primary task of distance goal \\
	- secondary task of repulsive field \\
	- damped least squares \\
	- task slowdown option \\
	- secondary task of manipulation measure \\	
}



\subsection{Constraints and Limits}

\add{
	- what is the point of this part anyways \\
	- YES, BUT HOW DO WE APPLY THOSE - this chapter only makes sense if we describe how the limits are applied
}

In robotic manipulators, effective path planning and motion control are subject to constraints related to free space, joint position limits, and joint velocity limits. These constraints are essential to ensure safety and practical functionality.

\textbf{Free Space Constraints:} These constraints ensure the manipulator operates in unoccupied space, avoiding obstacles. They are defined as:
\begin{equation}
	\mathcal{C}_{free}(\vec{x}) = \begin{cases} 
		1, & \text{if }\vec{x} \text{ is in free space} \\
		0, & \text{otherwise}
	\end{cases}
	\label{eq:free_space_constraint}
\end{equation}
This binary representation indicates whether a point in the workspace is in free space or obstructed. During the execution of our algorithm, the repulsive field guides the entire manipulator into the empty task space, which in turn moves the manipulator in the obstacle free configutaion space.

\textbf{Joint Position Limits:} Each joint of the manipulator has a range of motion determined by its mechanical design. These limits prevent the joints from exceeding their design capabilities, ensuring reliable operation:
\begin{equation}
	\theta_{i, min} \leq \theta_i \leq \theta_{i, max}
	\label{eq:joint_position_constraint}
\end{equation}
Here, \(\theta_{i, min}\) and \(\theta_{i, max}\) represent the minimum and maximum positions for each joint.

\textbf{Joint Velocity Limits:} Velocity limits are set for each joint to maintain controlled movements and prevent mechanical stress. These limits facilitate precise and stable motion:
\begin{equation}
	\dot{\theta}_{i, min} \leq \dot{\theta}_i \leq \dot{\theta}_{i, max}
	\label{eq:joint_velocity_constraint}
\end{equation}
The values \(\dot{\theta}_{i, min}\) and \(\dot{\theta}_{i, max}\) specify the minimum and maximum velocities for each joint.

\subsection{Attractive Velocity}

% FIRST DRAFT
%In the context of our robotic manipulator, the primary task requires an attractive force that directs the end effector (EE) towards the desired position and orientation. In the seminal work of Khatib, this task is defined in the context of the joint coordinate system and joint error. However, we have chosen to define the error of the primary target task in Cartesian coordinate space as the orientation and position error of the EE. This approach allows us to guide the manipulator to its target position and orientation without prior knowledge of its final joint configuration. This is particularly important in scenarios where the manipulator is redundant and there are multiple or potentially infinite positions that meet the requirements of the target and secondary tasks. Our method proves beneficial in efficiently identifying an optimal position in such cases since the target joint configuration of the manipulator is unknown.
%To compute the positional error of the end effector (EE), we evaluate the gradient of the squared difference between the vectors representing the current position of the EE and its goal position. Because we want the robot to move with constant velocity most of the way and only slow down when bigger precision is needed we calculate direction unit vector of this error and call it directional vector. This allows us to move at a speed that doesnt overwhelm repulsive secondary task, so that the robot has time to move around the obstacles. Just this however is not enoug, as the robot would move with a constant velocity and as such overshot the goal position. To solve this we multiply the velocity vector with a sigmoid function, specifically atan function. This allows us to have relatively constant speed most of the way and smoothly slow down when we approach the goal point and dont skip around the goal.

% SHORT
%In developing our method, an important part is a velocity profile that guides the end effector (EE) towards its target position and orientation Our methodology represents a deviation from the paradigm established by Khatib. We employ Cartesian coordinates to define the primary task's error, enabling the manipulator to reach its target without predetermined joint configurations. This is vital for redundant manipulators with multiple feasible configurations.
%Traditional methods using the gradient of squared distance lead to high initial velocities and decreased velocity near the target, potentially hindering lower priority tasks like obstacle avoidance. Our aim is a constant velocity profile, decelerating only near the target to prevent overshooting. We achieve this by normalizing the direction vector towards the target and modulating its magnitude with a sigmoid function, specifically atan(velocity). This allows steady movement, decreasing velocity as the target nears.
%The approach is encapsulated in the equation:
%\begin{equation} \vec{v}_{ATT} = \frac{\vec{x}_{EE} - \vec{x}_g}{||\vec{x}_{EE} - \vec{x}_g||} \times \arctan(||\vec{x}_{EE} - \vec{x}_g||) \end{equation}

%%LONG
%In the development of our method, a pivotal element is the integration of a velocity profile that effectively guides the end effector (EE) toward its designated target position and orientation. Our methodology represents a deviation from the paradigm established by Khatib. Instead of quantifying the primary task's error within the joint coordinate framework, we opt for a Cartesian coordinate representation. This aspect is important when the manipulator exhibits redundancy, characterized by multiple or potentially infinite configurations that satisfy the primary task's requirements and constraints. In such scenarios, it can becomes impractical, if not impossible, to predetermine the optimal goal joint configuration.
%
%Utilizing solely the gradient of the squared distance would result in a high initial velocity when distant from the target, followed by a progressively decreasing velocity upon nearing the target. Such a velocity profile is suboptimal, as the excessive initial velocity could potentially compromise lower priority tasks, such as obstacle avoidance and in leads to unnecessary slow speeds when approaching the target. Our objective is to maintain a consistent velocity profile for the majority of the trajectory, with a gradual deceleration as the goal is approached to avoid overshooting. To this end, we initially compute the unit vector of the distance from the target, yielding a normalized velocity in the required direction. However, this would lead to overshooting and instability near the target. To counteract this, we modulate the magnitude of this vector using a sigmoid function, specifically the atan function. This modulation ensures a constant movement for the majority of the time towards the target, with the sigmoid function effectively reducing the velocity in inverse relation when in near proximity to the target.
%The following equation encapsulates our approach:
%\begin{equation} 
%	\vec{v}_{ATT} = \frac{\vec{x}_{EE} - \vec{x}_g}{||\vec{x}_{EE} - \vec{x}_g||} \times \frac{\arctan(k_{sigm} \; ||\vec{x}_{EE} - \vec{x}_g||) }{pi/2}
%\end{equation}

\add{
	-equation references \\
	- citations \\
	- check if quat log equation is correct
}

% JUST RIGHT
Our method \remove{innovatively} employs inverse kinematics approach (IK) to guide the end effector (EE) towards its target, marking a departure from Khatib's joint coordinates approach in favor of a Cartesian coordinates framework. This is particularly beneficial in scenarios involving redundant manipulators, where determining an optimal goal joint configuration in advance is challenging.

When calculating translational velocity, we avoid the conventional gradient of the squared distance approach, which leads to high initial velocities and subsequently slow speeds near the target. Our aim is a consistent velocity throughout the trajectory, with controlled deceleration near the goal. This is achieved by first calculating the unit vector towards the target for direction, then modulating its magnitude using a sigmoid function, specifically the arctangent function, to prevent overshooting and ensure stable approaching motion.

\begin{equation} 
	\vec{v} = \frac{\vec{x}_{EE} - \vec{x}_g}{||\vec{x}_{EE} - \vec{x}_g||} \times \frac{\arctan(k_{sigm} \; ||\vec{x}_{EE} - \vec{x}_g||) }{pi/2}
	\label{eq: v_att}
\end{equation}

In the above equation (eq.~\ref{eq: v_att}), $\vec{v}$  represents the end effector's translational velocity towards the target, combining direction and magnitude. The terms $\vec{x}_{EE}$ and $\vec{x}_g$ denote the current and goal positions of the EE, respectively, in Cartesian coordinates. The unit vector calculation, $\frac{\vec{x}_{EE}-\vec{x}_g}{||\vec{x}_{EE}-\vec{x}_g||}$, ensures motion directed towards the target. Finally, the sigmoid function, particularly the arctangent component, modulates this velocity to avoid overshooting, balancing speed and precision. The constant $k_{sigm}$ allows us to set how close to the goal does the robot EE start slowing down.

The rotational velocity error of the EE is needed for ensuring goal orientation of the EE. In our approach, orientations are depicted using rotation matrices. Specifically, \( R \) represents the current EE orientation, while \( gR \) signifies the goal EE orientation. The disparity between these orientations is encapsulated by the relative rotation matrix \( dR \). This matrix is formulated by multiplying the goal orientation matrix \( gR \) with the transpose of the current orientation matrix \( cR^{T} \). To ensure that it represents a pure rotation without any scaling we than normalize the so gotten matrix .

\begin{equation}
	dR = \frac{gR \cdot cR^{T}}{||gR \cdot cR^{T}||}
	\label{eq: rot_diff_mat}
\end{equation}

The relative rotation matrix value is converted into a quaternion, which is then logarithmically transformed to represent the rotational error vectorially:

\begin{equation}
	dR \mapsto dQ = a + b \, i + c \, j + d \, k
	\label{eq: quat_mapsto}
\end{equation}

\begin{equation}
	dQl = 2 \cdot \log(dQ) = al + bl \, i + cl \, j + dl \, k
	\label{eq:quat_log}
\end{equation}

The components of this quaternion, excluding the real part, form the rotational error vector \( \omega \):

\begin{equation}
	\vec{\omega} =
	\begin{bmatrix}
		bl \\
		cl \\
		dl
	\end{bmatrix}
	\label{eq:rot_error_vector}
\end{equation}

To get the full velocity of the end effector (EE), \( \mathrm{\vec{v}_{ATT}} \), we combines translational and rotational velocities, which we scale using proportional gains \( k_p \) and \( k_r \).

\begin{equation}
	\mathrm{\vec{v}_{ATT}} = 
	\begin{bmatrix}
		k_p \times \vec{v}   \\
		k_{\omega} \times \vec{\omega}
	\end{bmatrix}
	\label{eq:ee_velocity}
\end{equation}

\subsection{Repulsive Velocity}

\add{	
	- object detection is done in task domain and not c-space (more logical) \\
	- repulsive field calculation - matrix "convolution" method \\
	- matrix size and shape selection \\
	- equation for repulsive kernel values (non-linear) \\
	- PLOT: (ERK) kernel graphics \\
	- PLOT: (ERK) linear kernel graphics \\
	- PLOT: kernel field shape 	\\
	- interpolation of the repulsive field \\
	- what if there are obstacles behind wall (usually not the case, depth sensors show only thin walls, some noise doesnt matter, non-linear kernel, possible additional pre-convolution to convert obstacle grid to edges) \\
	- effecient calculation in dinamic environments, lacking prediction capabilities (MPC) \\
}

\subsubsection{Kernel Selection}

\subsubsection{Interpolation}



\section{Implementation}

\section{Results}

\todo{3 PAGES}

\add{
	- include execution times \\
	- PLOT: kernel on robot graphics \\
}

\section{Discussion}

\todo{1 PAGE}

\add{
	- add the limitations of such method (already mentioned by Khatib) \\
	- the limitations of local search \\
	- number of parameters that need to be tuned (are there actually that many?)
}

\section{Conclusion}



\end{document}
