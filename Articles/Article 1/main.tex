% !TeX spellcheck = en_US
\documentclass[]{article}

\usepackage{amsmath, xparse}

\usepackage{graphicx}


 \usepackage{easyReview}


%opening
\title{\comment{3D Voxel Grid Based Path Planning for Robotic Manipulators using Matrix Multiplication Technique}{Alternatives:\\ - Efficient distance calculation / Efficient repulsive field calculation technique \\   - Matrix Multiplication-Driven Repulsive Fields for 3D Voxel-Based Robotic Manipulator Path Planning \\ - Robotic Manipulator Path Planning Optimization Using Matrix-Derived Repulsive Fields Based on 3D Voxel Grid}}

\author{Jakob Baumgartner, Gregor Klančar}

\begin{document}
	
\maketitle

\comment{}{for keywords use the SEO algorithm to find which terms are popular}

\begin{abstract}

\end{abstract}

\section{Introduction}

\section{Background}

\todo{1-2 PAGES}

\alert{Maybe add a sentence about computer effeciency of the method, as it is not dependent on the number of obstacles.}

\add{
	- PRESENT DISTANCE CALCULATION FOR MANIPULATORS (sensors, lidar, ir, bounding boxes) \\
	- PRESENT PATH PLANNING METHODS FOR MANIPULATOR (optimization, sampling, biological, learning) \\
	- similar to Distance Transform (a kind of inverted distance transform) \\
	- method was inspired by Khatib APF (however, it evolved into a different method) \\
	- different existing APF manipulator implementation articles \\
	- VFH \\
}

\section{Methodology}

\todo{3 PAGES}

\subsection{Kinematic Control}

We use inverse kinematics algorithm to calculate joint velocities based on the primary goal, that is EE position and secondary task of obstacle avoidance. \add{(INSERT: a sentence or two about ik algorithm, also a reference)} We also use additional secondary tasks, such as mid-joints position and more importantly manipulability task, which allows us to avoid some singularity positions of the manipulator arm and some local minima, which are a consequence of the local optimization approach used.

\comment{}{optimization algorithm diagram}

We start our algorithm in a start joint configuration, that can be previous goal position. We run optimization loop, that runs step by step from start to goal configuration, while avoiding obstacles / applieing constraints and limits. Each step we calculate the joint velocities and integrate them into new joint positions. Each of so gotten positions is one of the points on our joints trajectory. The priamry IK task is to take the manipulator EE to the desired goal position and orientation, we describe how to calculate cartesian velocities in the chapter ref:Attractive Velocity, which are than calculated into joint velocities. The size of this primary velociti is constant for the entire part of the optimization and is reduced only when approaching the goal. 

To avoid obstacles we calculate the avoidance velocities as descrubed in section~\ref{chap:repulsive velocity}. As one of the biggest problems of the APF Khatib method is local minima points, where the robot gets stuck in a point, where attractive and repulsive forces cancel each other out, we use transformation into the null space \add{(INSERT: add citation of null space robotics manipulators)} to only move the robot away from the obstacles in such a way as to not interfere with the main task. If not, the robot could not even approach the obstacles, which however is necessary in some situations, as it allows it to reach the goal points for which to reach the manipulator segments need to be positions in proximity to the obstacles. For this approach to work we need enough degree of manipulability left for the secondary task, so that the main / primary task doesnt overwhelm the secondary task. As described in the section~\ref{chap:attractive velocity} we solve this problem by normalizing the primary attractive velocity. 

\add{this can still sometimes lead to loss of manipulability, add terciary, or secondary maipulability task}

Another way we make sure that the primary task doesn't take over the avoidance task is using execution slowdown as described in section~\ref{chap:primary slowdown}.


\add{
	- robot kinematics the exact-reduced method \\
	- secondary task of manipulation measure \\	
	- different tasks merging equation \\
}

\subsubsection{Exact Reduced Inverse Kinematics Method}

\add{
	- cite žlajpah article \\
	- explain how it works \\
	- equation \\
	- scalar simplification	
}





\subsection{Constraints and Limits}

\alert{
	- what is the point of this part anyways \\
	- YES, BUT HOW DO WE APPLY THOSE - this chapter only makes sense if we describe how the limits are applied \\
}

\add{ 
	- add $x_{start}$ and $x_{goal}$ \\
}

%In robotic manipulators, effective path planning and motion control are subject to constraints related to free space, joint position limits, and joint velocity limits. These constraints are essential to ensure safety and practical functionality.
%
%\textbf{Free Space Constraints:} These constraints ensure the manipulator operates in unoccupied space, avoiding obstacles. They are defined as:
%\begin{equation}
%	\mathcal{C}_{free}(\vec{x}) = \begin{cases} 
%		1, & \text{if }\vec{x} \text{ is in free space} \\
%		0, & \text{otherwise}
%	\end{cases}
%	\label{eq:free_space_constraint}
%\end{equation}
%This binary representation indicates whether a point in the workspace is in free space or obstructed. During the execution of our algorithm, the repulsive field guides the entire manipulator into the empty task space, which in turn moves the manipulator in the obstacle free configutaion space.
%
%\textbf{Joint Position Limits:} Each joint of the manipulator has a range of motion determined by its mechanical design. These limits prevent the joints from exceeding their design capabilities, ensuring reliable operation:
%\begin{equation}
%	\theta_{i, min} \leq \theta_i \leq \theta_{i, max}
%	\label{eq:joint_position_constraint}
%\end{equation}
%Here, \(\theta_{i, min}\) and \(\theta_{i, max}\) represent the minimum and maximum positions for each joint.
%
%\textbf{Joint Velocity Limits:} Velocity limits are set for each joint to maintain controlled movements and prevent mechanical stress. These limits facilitate precise and stable motion:
%\begin{equation}
%	\dot{\theta}_{i, min} \leq \dot{\theta}_i \leq \dot{\theta}_{i, max}
%	\label{eq:joint_velocity_constraint}
%\end{equation}
%The values \(\dot{\theta}_{i, min}\) and \(\dot{\theta}_{i, max}\) specify the minimum and maximum velocities for each joint.

\subsection{Attractive Velocity}
\label{chap:attractive velocity}

% FIRST DRAFT
%In the context of our robotic manipulator, the primary task requires an attractive force that directs the end effector (EE) towards the desired position and orientation. In the seminal work of Khatib, this task is defined in the context of the joint coordinate system and joint error. However, we have chosen to define the error of the primary target task in Cartesian coordinate space as the orientation and position error of the EE. This approach allows us to guide the manipulator to its target position and orientation without prior knowledge of its final joint configuration. This is particularly important in scenarios where the manipulator is redundant and there are multiple or potentially infinite positions that meet the requirements of the target and secondary tasks. Our method proves beneficial in efficiently identifying an optimal position in such cases since the target joint configuration of the manipulator is unknown.
%To compute the positional error of the end effector (EE), we evaluate the gradient of the squared difference between the vectors representing the current position of the EE and its goal position. Because we want the robot to move with constant velocity most of the way and only slow down when bigger precision is needed we calculate direction unit vector of this error and call it directional vector. This allows us to move at a speed that doesnt overwhelm repulsive secondary task, so that the robot has time to move around the obstacles. Just this however is not enoug, as the robot would move with a constant velocity and as such overshot the goal position. To solve this we multiply the velocity vector with a sigmoid function, specifically atan function. This allows us to have relatively constant speed most of the way and smoothly slow down when we approach the goal point and dont skip around the goal.

% SHORT
%In developing our method, an important part is a velocity profile that guides the end effector (EE) towards its target position and orientation Our methodology represents a deviation from the paradigm established by Khatib. We employ Cartesian coordinates to define the primary task's error, enabling the manipulator to reach its target without predetermined joint configurations. This is vital for redundant manipulators with multiple feasible configurations.
%Traditional methods using the gradient of squared distance lead to high initial velocities and decreased velocity near the target, potentially hindering lower priority tasks like obstacle avoidance. Our aim is a constant velocity profile, decelerating only near the target to prevent overshooting. We achieve this by normalizing the direction vector towards the target and modulating its magnitude with a sigmoid function, specifically atan(velocity). This allows steady movement, decreasing velocity as the target nears.
%The approach is encapsulated in the equation:
%\begin{equation} \vec{v}_{ATT} = \frac{\vec{x}_{EE} - \vec{x}_g}{||\vec{x}_{EE} - \vec{x}_g||} \times \arctan(||\vec{x}_{EE} - \vec{x}_g||) \end{equation}

%%LONG
%In the development of our method, a pivotal element is the integration of a velocity profile that effectively guides the end effector (EE) toward its designated target position and orientation. Our methodology represents a deviation from the paradigm established by Khatib. Instead of quantifying the primary task's error within the joint coordinate framework, we opt for a Cartesian coordinate representation. This aspect is important when the manipulator exhibits redundancy, characterized by multiple or potentially infinite configurations that satisfy the primary task's requirements and constraints. In such scenarios, it can becomes impractical, if not impossible, to predetermine the optimal goal joint configuration.
%
%Utilizing solely the gradient of the squared distance would result in a high initial velocity when distant from the target, followed by a progressively decreasing velocity upon nearing the target. Such a velocity profile is suboptimal, as the excessive initial velocity could potentially compromise lower priority tasks, such as obstacle avoidance and in leads to unnecessary slow speeds when approaching the target. Our objective is to maintain a consistent velocity profile for the majority of the trajectory, with a gradual deceleration as the goal is approached to avoid overshooting. To this end, we initially compute the unit vector of the distance from the target, yielding a normalized velocity in the required direction. However, this would lead to overshooting and instability near the target. To counteract this, we modulate the magnitude of this vector using a sigmoid function, specifically the atan function. This modulation ensures a constant movement for the majority of the time towards the target, with the sigmoid function effectively reducing the velocity in inverse relation when in near proximity to the target.
%The following equation encapsulates our approach:
%\begin{equation} 
%	\vec{v}_{ATT} = \frac{\vec{x}_{EE} - \vec{x}_g}{||\vec{x}_{EE} - \vec{x}_g||} \times \frac{\arctan(k_{sigm} \; ||\vec{x}_{EE} - \vec{x}_g||) }{pi/2}
%\end{equation}

\add{
	-equation references \\
	- citations \\
	- check if quat log equation is correct
}

% JUST RIGHT
Our method \remove{innovatively} employs inverse kinematics approach (IK) to guide the end effector (EE) towards its target, marking a departure from Khatib's joint coordinates approach in favor of a Cartesian coordinates framework. This is particularly beneficial in scenarios involving redundant manipulators, where determining an optimal goal joint configuration in advance is challenging.

When calculating translational velocity, we avoid the conventional gradient of the squared distance approach, which leads to high initial velocities and subsequently slow speeds near the target. Our aim is a consistent velocity throughout the trajectory, with controlled deceleration near the goal. This is achieved by first calculating the unit vector towards the target for direction, then modulating its magnitude using a sigmoid function, specifically the arctangent function, to prevent overshooting and ensure stable approaching motion.

\begin{equation} 
	\vec{v} = \frac{\vec{x}_{EE} - \vec{x}_g}{||\vec{x}_{EE} - \vec{x}_g||} \times \frac{\arctan(k_{sigm} \; ||\vec{x}_{EE} - \vec{x}_g||) }{pi/2}
	\label{eq: v_att}
\end{equation}

In the above equation (eq.~\ref{eq: v_att}), $\vec{v}$  represents the end effector's translational velocity towards the target, combining direction and magnitude. The terms $\vec{x}_{EE}$ and $\vec{x}_g$ denote the current and goal positions of the EE, respectively, in Cartesian coordinates. The unit vector calculation, $\frac{\vec{x}_{EE}-\vec{x}_g}{||\vec{x}_{EE}-\vec{x}_g||}$, ensures motion directed towards the target. Finally, the sigmoid function, particularly the arctangent component, modulates this velocity to avoid overshooting, balancing speed and precision. The constant $k_{sigm}$ allows us to set how close to the goal does the robot EE start slowing down.

The rotational velocity error of the EE is needed for ensuring goal orientation of the EE. In our approach, orientations are depicted using rotation matrices. Specifically, \( R \) represents the current EE orientation, while \( gR \) signifies the goal EE orientation. The disparity between these orientations is encapsulated by the relative rotation matrix \( dR \). This matrix is formulated by multiplying the goal orientation matrix \( gR \) with the transpose of the current orientation matrix \( cR^{T} \). To ensure that it represents a pure rotation without any scaling we than normalize the so gotten matrix .

\begin{equation}
	dR = \frac{gR \cdot cR^{T}}{||gR \cdot cR^{T}||}
	\label{eq: rot_diff_mat}
\end{equation}

The relative rotation matrix value is converted into a quaternion, which is then logarithmically transformed \remove{to represent the rotational error vectorially}. The components of this quaternion, excluding the real part, than form the rotational error vector \( \omega \).

\begin{equation}
	dR \mapsto dQ = a + b \, i + c \, j + d \, k
	\label{eq: quat_mapsto}
\end{equation}

\begin{equation}
	dQl = 2 \cdot \log(dQ) = al + bl \, i + cl \, j + dl \, k
	\label{eq:quat_log}
\end{equation}

\alert{There needs to be an explanation why log, where is this from. Maybe a reference. cite: DMP Quaternions article Petrič, Žlajpah, Ude}



\begin{equation}
	\vec{\omega} =
	\begin{bmatrix}
		bl \\
		cl \\
		dl
	\end{bmatrix}
	\label{eq:rot_error_vector}
\end{equation}

To get the full velocity of the end effector (EE), \( \mathrm{\vec{v}_{ATT}} \), we combines translational and rotational velocities, which we scale using proportional gains \( k_p \) and \( k_r \).

\begin{equation}
	\mathrm{\vec{v}_{ATT}} = 
	\begin{bmatrix}
		k_p \times \vec{v}   \\
		k_{\omega} \times \vec{\omega}
	\end{bmatrix}
	\label{eq:ee_velocity}
\end{equation}

\subsubsection{Primary Task Slowdown}
\label{chap:primary slowdown}

To ensure the primary task doesn't overpower the secondary task, we've integrated a primary task execution slowdown. This mechanism can reduce the manipulator's velocity towards its primary goal, leaving more maneuverability space for the secondary tasks.

\begin{equation}
	\label{eq:slowdown}
	\xi_{p}=
	\frac{1}{1 + \kappa_{\text{sec}} \left(\frac{1}{\delta_{min}}\right)}
\end{equation}

\alert{Is this equation correct, ADD a singularity damping factor. Maybe even some variation of a changing damping.}

The slowdown factor (eq.~\ref{eq:slowdown}) is influenced by the constant \( \kappa_{\text{sec}} \) and the robot's minimum distance from an obstacle \( \delta_{\text{min}} \). We calculate the minimal distance in the repulsive velocities phase of the algorithm, as explained in section~\ref{chap:repulsive velocity}. As per the equation, a large \( \delta_{\text{min}} \) minimizes the slowdown effect, allowing uninterrupted primary task execution. Conversely, a small \( \delta_{\text{min}} \) increases the slowdown, by making the $\xi_{p}$ factor smaller, giving the secondary task more time for corrective actions.

\alert{THIS WILL TOTALLY STOP MOVEMENT IN TIGHT SPACES, NEED ADDITIONAL PART. (Maybe use some kind of derivative of Rep Field).}

\subsection{Repulsive Velocity}
\label{chap:repulsive velocity}

%We compute obstacle distances in task space with our unique matrix kernel method. Focusing on task space is beneficial as it provides a more direct and realistic representation of the environment, leading to better spatial awareness, quicker responsiveness, easier sensor integration, and more effective obstacle avoidance. Our method is particularly effective when integrating noisy sensor inputs like LIDAR or depth cameras for obstacle avoidance, as it efficiently processes and utilizes this spatial information, even in the presence of noise, to accurately determine repulsive velocities.
%
% Odbojne sile so odvisne od oddaljenosti od ovir oz. objekotv v prostoru. Odbojno polje mora pasti na nič, ko smo oddaljeni od ovir za neko maksimalno razdaljo in narasti na maksimalno vrednost, ko smo tik ob oviri. 
% 
% Izračunati želimo odbojne sile v različnih točkah interesa na manipulatorju. \add{citation for this approach} Te točke strategično porazdelimo po manipulatorju tako, da je celotna okolica manipulatorja pokrita z matrikami odbojnega polja. 
% 
% Med izračunom odbojnega polja uporabimo kinematične enačbe, da pozicijo točk iz prostora notranjih spremenljivk (sklepov) robota transformiramo v prostor naloge, oz kartezični prostor. 
% 
% Ko imamo pozicijo točk na robotu v kartezičnem prostoru, predlagamo izračun vrednost odbojnega polja v posamezni točki na dva različna načina. Prostor ovir v katerem se nahaja naš robot je predstavljen kot mreža zasedenosti, v kateri imajo posamezni voxli vrednosti med 0, če se v prostoru ovira zagotovo ne nahaja in vrednost 1, če smo zagotovo prepričani, da tam je ovira, običajno pa je vrednost nekje med tema dvema skrajnostima. Prostor ovir ima svojo resolucijo, je diskreten, medtem ko je kartezični prostor zvezen. Ker za naš pristop potrebujemo poznati katere in kako zasedene celice se nahajajo v okolici našega robota predlagamo dva načina preslikave v prostor mreže zasedenosti. Enostavnejši pristop je, da točko na robotu v kateri želimo ugotoviti vrednost odbojnega polja enostavno preslikamo v center najbličje celice, glede na eulerjevo razdaljo. Včasih pa lahko zaradi te diskretizacije pride do nezveznosti. Zato predlagamo drugi pristop, linearno interpolacijo izračunanega odbojnega polja, da dobimo zvezno vrednost polja.
% 
% Ko smo pozicijo točke na manipulatorju z eno od metod preslikali v prostor ovir, lahko uporabimo naša odbojna konvolucijska jedra, za izračun odbojnih hitrosti. Za vsako od kartezičnih smeri (x,y,z) bomo generirali odbojno jedro, kot je opisano v poglavju "Odbojna konvolucijska jedra". Nato iz mreže ovir za vsako od treh smeri izrežemo matrično okno, ki je enake dimenzije kot je so jedra, z centrom v naši točki. Z množenjem isto ležnih elementov (Hadamardov produkt), izrezanega okna ovir in naše odbojne matrike, dobimo rezultančno matriko. Ko vse elemente matrike seštejemo, dobimo odbojno hitrost za posamezno karttezično smer v izbrani točki.
% 
% \subsubsection{Način najbližjega polja}
% 
% \subsubsection{Način interpolacije}

In our method, we compute repulsive velocities within the task space using a novel matrix kernel multiplication approach. Concentrating on the task space is advantageous as it provides a more direct and realistic representation of the environment. \replace{This leads to improved spatial awareness, faster responsiveness, and is particularly well-suited for integrating noisy sensor inputs like LIDAR or depth cameras, efficiently processing and using this spatial information to accurately determine repulsive velocities, even amidst noise.}{add some references for this statement}

Repulsive velocities tell the manipulator in which direction to move, so that it avoids nearby obstacles. These velocities drop to zero when the manipulator maintains a minimum safe distance from obstacles, and rise to their highest when it nears an obstacle, facilitating immediate evasive action. 

Our goal is to calculate repulsive forces at various points of interest on the manipulator. These points \add{add reference} are strategically distributed across the manipulator to ensure that the entire area of the robot is covered by the matrices of the repulsive field.

During the calculation of the repulsive field, kinematic equations are utilized to transform the position of points from the robot's internal joint space to the Cartesian global coordinate space.

The space of obstacles in which our robot operates is represented as an occupancy grid, where individual voxels have values ranging from 0 (indicating no obstacle presence) to 1 (certainty of an obstacle), with typical values lying somewhere between these extremes. Since the obstacle space is discrete (has finite resolution), while the Cartesian space is continuous, we propose two methods for mapping from Cartesian space to the occupancy grid space. The simpler approach involves mapping the point directly to the center of the nearest occupancy grid voxel, based on Euclidean distance. However, this discretization can sometimes lead to discontinuities. Therefore, we propose a second approach: linear interpolation of the calculated repulsive field to achieve a continuous field value.

Once the position of a point on the manipulator has been mapped to the obstacle space using one of these methods, we can employ our repulsive convolutional kernels to calculate repulsive velocities. For each Cartesian direction $(x, y, z)$, we will generate a repulsive kernel, as described in the section~\ref{chap:kernels}. Then, from the obstacle grid, for each of the three directions, we extract a matrix cutout window of the same dimension as the kernels, centered on the point of interest. By performing the Hadamard (element-wise) product of the extracted obstacle grid window and our repulsive matrix, we obtain a resultant matrix. Summing all the elements of this matrix gives us the repulsive velocity for each of the three Cartesian directions at the selected point.

\includegraphics[width=1\textwidth]{manipulator-kernels-visualization-grid-small.eps}


\begin{equation}
	\mathrm{\vec{v}_{poi}} = 
	\begin{bmatrix}
	\sum_{(i, j, k)} W_x \odot K_x \\
	\sum_{(i, j, k)} W_y \odot K_y \\
	\sum_{(i, j, k)} W_z \odot K_z	
	\end{bmatrix}
	\label{eq:poi_velocity}
\end{equation}



 
 \add{
 	-there is an option of interpolation plot different matrixes, that are sligthely moved ... \\
 	-in results maybe compare smoothenss of interpolated and non-interpolated method
 }
 
 

\add{
	- kinematic calculations \\
	- null spaces calculations \\
	- how to join multiple velocities - weights \\
	- general overview	\\
}

***

\add{	
	- object detection is done in task domain and not c-space (more logical) \\
	- repulsive field calculation - matrix "convolution" method \\
	- matrix size and shape selection \\
	- equation for repulsive kernel values (non-linear) \\
	- PLOT: (ERK) kernel graphics \\
	- PLOT: (ERK) linear kernel graphics \\
	- PLOT: kernel field shape 	\\
	- what if there are obstacles behind wall (usually not the case, depth sensors show only thin walls, some noise doesnt matter, non-linear kernel, possible additional pre-convolution to convert obstacle grid to edges) \\
	- effecient calculation in dinamic environments, lacking prediction capabilities (MPC) \\
	- good for working in "statistical, noisy" obstacle grids
}

\subsubsection{Kernel Selection}
\label{chap:kernels}

The fundamental concept of our directional kernels lies in computing the repulsive field individually for each direction within the Cartesian coordinate system.\remove{ Our filters share a passing similarity to the Sobel  operator, a 2D convolutional filter frequently utilized in computer vision for calculating image gradients at specific points.}

Our kernels are designed as three-dimensional structures with a primary kernel axis aligned along a specific Cartesian direction, corresponding to the calculated repulsive velocity. The two secondary kernel axes are orthogonal to this primary axis. The distribution of values along the primary axis is inversely symmetric, exhibiting positive values on one side and negative values on the other, with the jump between max positive and max negative magnitude at the kernel's center. The function of the increase in magnitude along the primary axis of the kernel defines the shape of the repulsive velocity field, determining how the repulsive velocity changes as the point on the manipulator approaches an obstacle.

The length of the primary axis is critical, as it dictates the detection range for obstacles. Longer kernels can detect obstacles further away
from the robot, essentially extending the ’safety zone’ around the robot. If the primary axis is too long, it can lead to extra calculations and may cause the robot to unnecessarily avoid obstacles that aren't in its immediate path, making its movement and path planning less efficient. A kernel with a primary axis that is too short might restrict the robot's ability to maneuver, detecting obstacles potentially too late, compromising the robots capacity to avoid obstacles effectively (eq. \ref{eq: detect range}). Moreover, it is essential for the magnitudes at the kernel's periphery to be minimal, promoting a smooth increase in repulsive velocity when approaching the obstacle rather than a sudden spike.

\begin{equation}
	\label{eq: detect range}
	len_{primary} = \frac{2 \times \mathrm{range}}{\Delta \mathrm{grid}}\\
\end{equation}

%\remove{In the orthogonal axes, the magnitude of values diminishes with increasing distance from the core of the kernel, nearing zero at the edges. This gradation is vital for a smooth velocity transition when obstacles emerge in the kernels range. The peak magnitude is located at the kernel's core, along the primary axis. The polarity of the values is determined by their position relative to the primary axis. }

The length of the orthogonal axes influences the peripheral detection range for obstacles. Excessively wide kernels may generate repulsive velocities for objects that are not in the path of the robot, whereas too narrow kernels might only detect obstacles aligned directly with the Cartesian direction in the point of interest. When selecting the width and height of the kernel, we must consider the density of the neighboring points of interest on the robot, ensuring that the \replace{collective fields}{combination of kernels} adequately cover the entire manipulator's surrounding area.

\comment{}{PLOT: kernel with gaussian functions}
\comment{}{EQUATION: gaussian equations}

\add{- choice of velocity profile (gaussian, linear ... maybe could move this part to implementation / experiments) \\}
\add{- maybe first debluring - line convolution operation (if thick walls) - however this might move wall back, which could cause crash }



\subsubsection{Interpolation of the Repulsive Velocity}

%Želimo, da je gibanje robota zvezno in ne skokovito. Da lahko to dosežemo je potrebno, da vsi hitrostni prispevki, ki vplivajo na robota prehajajo med seboj zvezno. Ker imamo mrežo ovir diskretno definirano, to ni res. Z zvišanjem resolucije polja ovir in se lahko zveznosti teoretično neskončno približamo, vendar pa imamo v realnosti običajno opravka z končno resolucijo. Da je velikost hitrosti kljub temu zvezna, ko prehajamo z točko interesa POI iz ene celice mreže ovir v drugo, uporabimo trilinearno interpolacijo, s katero za vsako od hitrosti v treh kartezičnih smeri posebaj interpoliramo hitrosti in dobimo zvezno in neskokovito linearno aproksimacijo pri prehodu med celicami. 
%
%Ko poznamo koordinate naše POI izračunamo za vsako od točk x,y in z koordinate zaokrožene navzgor in navzdol, da dobimo 8 okoliških celic. 
%
%Ko imamo poznane celice, uporabimo našo poznano konvolucijsko metodo, da izračunamo x,y in z komponento vektorja odbojne hitrosti za vsako od celic.
%
%Potem izvedemo za vsako od smeri vektorja odbojne hitrosti posebaj trilinearno interpolacijo odbojne hitrosti. Pri tem upoštevamo, da se izraučunane vrednosti odbojnih hitrosti nahajajo v centrih celic, pri interpolaciji torej zamaknemo koordinate poznanih vrenodsti za polovico resolucije mreže ovir v vsaki od smeri. Rezultat je vektor odbojne hitrosti, ki zvezno prehaja med diskretnimi vrednostmi izračunanimi v diskretnih točkah mreže ovir.
%

It is essential that the velocity contributions affecting the robot change smoothly. However, since our obstacle grid is discretely defined, achieving perfect continuity can be challenging. Increasing the resolution of the obstacle field can theoretically bring us closer to continuous behavior, but in practice, we are constrained by finite resolution. To ensure that the velocity remains continuous when transitioning from one cell of the obstacle grid to another at a point of interest (POI), we employ trilinear interpolation. \remove{This technique allows for a smooth and continuous linear approximation of velocities in all three Cartesian directions (x, y, and z) as the POI moves between cells.}

We start by scalling the coordinates of POI into the grid koordinate system, by multiplying it by grid resolution (eq.~\ref{eq:scale grid}). 

\begin{equation}
	\label{eq:scale grid}
	\vec{P} = \vec{p}_{\mathrm{POI}} \times\Delta \mathrm{grid}
\end{equation}

We get the indexes of the surrounding cells by first scaling the POI position by grid resolution and than rounding the position to the nearest lower and upper integer positions (eq.~\ref{eq:floor and ceil}).

%\begin{equation}
% X = \left[ \lfloor p_{x} \rfloor, \lceil p_{x} \rceil \right] 
%\end{equation}
%
%\begin{equation}
% Y = \left[ \lfloor p_{y} \rfloor, \lceil p_{y} \rceil \right] 
%\end{equation}
%
% \begin{equation}
% Z = \left[ \lfloor p_{z} \rfloor, \lceil p_{z} \rceil \right] 
%\end{equation}
	
	\begin{equation}
		\label{eq:floor and ceil}
		\vec{P} =
		\begin{bmatrix}
			X \\
			Y \\
			Z \\
		\end{bmatrix}
		=
		\begin{bmatrix}
			\; \lfloor \vec{p}_{\mathrm{POI}}(1) \rfloor \; \lceil \vec{p}_{\mathrm{POI}}(1) \rceil \;  \\
			\; \lfloor \vec{p}_{\mathrm{POI}}(2) \rfloor \; \lceil \vec{p}_{\mathrm{POI}}(2) \rceil \; \\
			\; \lfloor \vec{p}_{\mathrm{POI}}(3) \rfloor \; \lceil \vec{p}_{\mathrm{POI}}(3) \rceil \; 
		\end{bmatrix}
	\end{equation}

Once we got the indexes of the eight surrounding cells of our POI, we use our kernel matrix multiplication method, to calculate the 3x1 repulsive velocity vectors for all the cells (eq.~\ref{eq: calc rep vel}).

\begin{equation}
	\label{eq: calc rep vel}
	\vec{V}rep_{xyz,ijk} = \mathrm{calc\_rep\_vel}(X[i], Y[j], Z[k]) \quad \forall i, j, k \in \{1, 2\}
\end{equation}

Trilinear interpolation method works on a 3-dimensional regular grid. Before we can start with the interpolation we need to calculate the distance between POI and smaller coordinates of the cells where we calculated the repulsive velocities (eq.~\ref{eq: deltas interp}). \replace{Since the repulsive values we calculate for the cells are alligned with the centers of the cells, we need to move before the interpolation the positions of known grid points by half of the cell width.}{The calculated repulsive velocity values are located at the centers of the cells. Therefore, before interpolation, we shift the values of the cells coordinates by half the resolution of the obstacle grid for each direction. }

%\begin{equation}
%	\Delta X = \frac{\left( P_x - \left( X(1) + \frac{1}{2} \Delta \mathrm{grid} \right)  \right)}{\left( X(2) - X(1) \right)}
%\end{equation}
%
%\begin{equation}
%	\Delta Y = \frac{\left( P_y - \left( Y(1) + \frac{1}{2} \Delta \mathrm{grid} \right)  \right)}{\left( Y(2) - Y(1) \right)}
%\end{equation}
%
%\begin{equation}
%	\Delta Z = \frac{\left( P_z - \left( Z(1) + \frac{1}{2} \Delta \mathrm{grid} \right)  \right)}{\left( Z(2) - Z(1) \right)}
%\end{equation}

\begin{equation}
	\label{eq: deltas interp}
	\Delta \vec{P} =
	\begin{bmatrix}
		\Delta x \\
		\Delta y \\
		\Delta z		
	\end{bmatrix}
	=
	\begin{bmatrix}
		 \frac{\left( P_x - \left( X(1) + \frac{1}{2} \Delta \mathrm{grid} \right)  \right)}{\left( X(2) - X(1) \right)} \\
		 \frac{\left( P_y - \left( Y(1) + \frac{1}{2} \Delta \mathrm{grid} \right)  \right)}{\left( Y(2) - Y(1) \right)} \\
		 \frac{\left( P_z - \left( Z(1) + \frac{1}{2} \Delta \mathrm{grid} \right)  \right)}{\left( Z(2) - Z(1) \right)} \\
 	\end{bmatrix}
\end{equation}

The result of the interpolation is independent of the order of the operations. We first interpolate along the x-axis, followed by along the y-axis and finally along z-axis.

%\begin{equation}
%	\vec{V}_{rep,00} = \vec{V}_{rep,000}(1 - x_d) + \vec{V}_{rep,100}x_d
%\end{equation}
%\begin{equation}
%	\vec{V}_{rep,01} = \vec{V}_{rep,001}(1 - x_d) + \vec{V}_{rep,101}x_d
%\end{equation}
%\begin{equation}
%	\vec{V}_{rep,10} = \vec{V}_{rep,010}(1 - x_d) + \vec{V}_{rep,110}x_d
%\end{equation}
%\begin{equation}
%	\vec{V}_{rep,11} = \vec{V}_{rep,011}(1 - x_d) + \vec{V}_{rep,111}x_d
%\end{equation}

\begin{equation}
	\label{eq: interp x}
	\vec{V}rep_{xyz,jk} = \vec{V}rep_{xyz,0jk}(1 - \Delta x) + \vec{V}rep_{xyz,1jk} \, \Delta x \quad \forall \, j, k \in \{1, 2\}
\end{equation}

%\begin{equation}
%	\vec{V}rep_{xyz,0} = \vec{V}rep_{xyz,00}(1 - \Delta y) + \vec{V}rep_{xyz,10} \, \Delta y
%\end{equation}
%
%\begin{equation}
%	\vec{V}rep_{xyz,1} = \vec{V}rep_{xyz,01}(1 - \Delta y) + \vec{V}rep_{xyz,11} \, \Delta y
%\end{equation}

\begin{equation}
	\label{eq: interp y}
	\vec{V}rep_{xyz,k} = \vec{V}rep_{xyz,0k}(1 - \Delta y) + \vec{V}rep_{xyz,1k} \, \Delta y \quad \forall \, k \in \{1, 2\}
\end{equation}

\begin{equation}
	\label{eq: interp z}
	\vec{V}rep_{xyz} = \vec{V}rep_{xyz,0}(1 - \Delta z) + \vec{V}rep_{xyz,1} \, \Delta z 
\end{equation}

The final result is a repulsive velocity vector that transitions smoothly between the discrete values calculated at distinct points in the obstacle grid.

\comment{}{PLOT: surrounding cells, interp grid}

\section{Implementation}

\section{Results}

\todo{3 PAGES}

\add{
	- include execution times \\
	- PLOT: kernel on robot graphics \\
	- IMPORTANT: maybe add 2D mobile platform results \\
	- use pybullet or some engine that tells you distance from obstacles and run the same task, compare distances after execution, smoothness of paths (MAYBE FOR PUBLICATION, NOT CONFERENCE)
}



\section{Discussion}

\todo{1 PAGE}

\add{
	- add the limitations of such method (already mentioned by Khatib) \\
	- the limitations of local search \\
	- good for parellelization \\
	- number of parameters that need to be tuned (are there actually that many?)
}

\section{Conclusion}



\end{document}
